---
title: 'CurvilinearGrids.jl: A Julia package for curvilinear coordinate transformations'
tags:
  - Julia
  - mesh
  - grids
  - curvilinear
authors:
  - name: Samuel C. Miller
    orcid: 0000-0001-6452-2308
    equal-contrib: true
    affiliation: 1
affiliations:
 - name: Laboratory for Laser Energetics, University of Rochester, Rochester, NY USA
   index: 1
date: 13 October 2024
bibliography: references.bib

---

# Summary

`CurvilinearGrids.jl` is a Julia package for computing grid metrics required for curvilinear coordinate transformations in arbitrary 1D, 2D, and 3D geometry. Curvilinear coordinate transformations are often used for finite-difference discretizations of partial differential equations, see for example, the Euler and Navier-Stokes equations in References [@visbal2002; @chandravamsi2023]. These coordinate transformations need to adhere to strict conservation laws that make the computation of grid metrics more difficult that simple finite-difference methods.

The API in `CurvilinearGrids.jl`  is designed to handle the complicated book-keeping associated with metric computation on multidimensional meshes. The aim is to simplify the process by which arbitrary curvilinear geometry is incorporated into various PDE-oriented codes discretized through finite-differences. Users provide `CurvilinearGrids.jl` with discrete coordinate points defined in real-space $(x,y,z)$, or functional forms, e.g `x(i,j), y(i,j)`. These are used to compute the Jacobian matrices required to transform to a uniform computational coordinate space $(\xi,\eta,\zeta)$. A common example of this is to use a body-fit or conformal grid and transform it so that it becomes a uniform grid in $(\xi,\eta,\zeta)$. Standard finite-difference stencils can be used on the uniform transformed grid. Figure \autoref{fig:grid} shows an example of a curvilinear grid defined in real-space and it's representation in computational space. 

![Curvilinear grid transformation.\label{fig:grid}](mesh.png)

The grid in \autoref{fig:grid} is generated by the following code snippet.
```julia
using CurvilinearGrids

function wavygrid(ni, nj, nhalo=1)
  Lx = Ly = 12
  n_xy = n_yx = 6
  xmin = -Lx / 2
  ymin = -Ly / 2

  Δx0 = Lx / (ni - 1)
  Δy0 = Ly / (nj - 1)

  Ax = 0.4 / Δx0
  Ay = 0.8 / Δy0

  # coordinate arrays
  x = zeros(ni, nj)
  y = zeros(ni, nj)

  @inbounds for idx in CartesianIndices(x)
    i,j = idx.I
    x[i, j] = xmin + Δx0 * (
        (i - 1) + Ax * sinpi((n_xy * (j - 1) * Δy0) / Ly)
    )
      
    y[i, j] = ymin + Δy0 * (
        (j - 1) + Ay * sinpi((n_yx * (i - 1) * Δx0) / Lx)
    )
  end

  return CurvilinearGrid2D(x, y, nhalo)
end

# number of nodes/vertices in each dimension
nx, ny = (30, 40)

nhalo = 2 # halo cells needed for stencils (can be set to 0)
grid = wavygrid(nx, ny, nhalo)
```

When solving transformed PDEs in computational coordinates ($\xi,\eta,\zeta$), grid metrics must be included. Care must be taken if advection or motion is included in the governing equations so that the geometric conservation law (GCL) is observed [@thomas1979]. If the scheme does not follow the GCL, errors will build up and ultimately corrupt the solution. In the case of fluid dynamics, the mesh and governing equation discretizations must follow the same scheme and be *conservative* [@visbal2002]. One such conservative scheme is the Monotone Explicit Gradient (MEG) based reconstruction [@chamarthi2023; @chandravamsi2023], which is included in `CurvilinearGrids.jl`. Other common schemes include weighted essentially non-oscillatory (WENO) schemes of various order. There is no restriction to particular schemes which can be added in the future.

Both edge-centered $(i\pm1/2, j\pm1/2)$ and cell-centered metrics $(i,j)$ are required for many PDE discretizations -- the interpolation from cell-center to edge must be consistent. An example of this is from the 6th-order MEG scheme seen below: 
$$
\begin{aligned}
\phi_{i+1/2} &= \frac{1}{2} \left ( \phi^L_{i+1/2} + \phi^R_{i+1/2} \right) \\
             &= \frac{1}{2} \left [ 
                \left (\phi_{i} + \frac{1}{2} \phi'_{i} + \frac{1}{12} \phi''_{i} \right ) +
                \left (\phi_{i+1} + \frac{1}{2} \phi'_{i+1} + \frac{1}{12} \phi''_{i+1} \right )
             \right ]
\\
\phi_{i-1/2} &= \frac{1}{2} \left ( \phi^L_{i-1/2} + \phi^R_{i-1/2} \right) \\
             &= \frac{1}{2} \left [ 
                \left (\phi_{i-1} + \frac{1}{2} \phi'_{i-1} + \frac{1}{12} \phi''_{i-1} \right ) +
                \left (\phi_{i} + \frac{1}{2} \phi'_{i} + \frac{1}{12} \phi''_{i} \right )
             \right ]
\end{aligned}
$$
Where the first derivative is defined as
$$
\begin{aligned}
 \left ( \frac{\partial \phi}{\partial \xi} \right )_i  = 
 \frac{3}{4}  (\phi_{i+1} + \phi_{i-1}) +
 \frac{3}{20} (\phi_{i+2} + \phi_{i-2}) +
 \frac{1}{60} (\phi_{i+3} + \phi_{i-3}),
\end{aligned}
$$
and the second derivative is
$$
\begin{aligned}
 \left ( \frac{\partial^2 \phi}{\partial \xi^2} \right )_i  = 
 2(\phi_{i+1} - 2\phi_i + \phi_{i-1}) +
 \frac{1}{2} \left [ \left ( \frac{\partial \phi}{\partial \xi} \right )_{i+1} - 
 \left ( \frac{\partial \phi}{\partial \xi} \right )_{i-1} \right ].
\end{aligned}
$$
At boundaries, one-sided or partially one-sided finite difference equations must be used.

Terminology in the literature can be confusing, but the "Jacobian matrix" is the matrix of partial derivatives that describe the forward or inverse transformation, and uses a bold-face $\textbf{J}$. The "Jacobian" then refers to the determinant of the Jacobian matrix, and is the non-bolded $J$. Some authors refer to the matrix as the "Jacobi matrix" as well. The forward transformation, or $T: (\xi,\eta,\zeta) \rightarrow (x,y,z)$ is defined as
$$
\textbf{J} = 
\begin{bmatrix}
x_\xi & x_\eta & x_\zeta \\
y_\xi & y_\eta & y_\zeta \\
z_\xi & z_\eta & z_\zeta
\end{bmatrix}, \quad J = \det [\textbf{J}]
$$
The inverse transformation $T^{-1}$: $(x,y,z) \rightarrow (\xi,\eta,\zeta)$ is defined as
$$
\textbf{J}^{-1} = 
\begin{bmatrix}
\xi_x   & \xi_y   & \xi_z   \\
\eta_x  & \eta_y  & \eta_z  \\
\zeta_x & \zeta_y & \zeta_z
\end{bmatrix}, \quad J^{-1} = \det [\textbf{J}^{-1}]
$$

The grid metrics are accessed through the `AbstractCurvilinearGrid` types exported by `CurvilinearGrids.jl`. The API currently supports 1D, 2D, and 3D geometry, with axisymmetric modes for 1D (spherical and cylindrical) and 2D (cylindrical RZ). Metrics are contained in `StructArrays` for each dimension.

Each grid type includes example metrics like the following subset:

- Cell centered metrics: $\eta_y, y_\xi$ via `grid.cell_center_metrics`
- Edge centered conservative metrics (`grid.edge_center_metrics`): $\hat{\xi}_{x1}, \hat{\xi}_{x2}, \hat{\xi}_{x3}$ at $i+1/2, j+1/2, k+1/2$
- Temporal metrics: $\xi_t, \eta_t, \zeta_t$ 

# References